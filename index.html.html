<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Glass Tetris</title>
<style>
  :root{
    --glass-bg: rgba(255,255,255,0.12);
    --glass-border: rgba(255,255,255,0.35);
    --shadow: 0 10px 30px rgba(0,0,0,0.25);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color: transparent;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;}
  body{overflow:hidden;background:#111;color:#fff;}
  /* カラフルなブラー背景（アニメするグラデーションの塊） */
  .bg{
    position:fixed;inset:0;overflow:hidden;z-index:-2;
    background: radial-gradient(600px 600px at 20% 30%, #ff8a00 0%, transparent 60%),
                radial-gradient(500px 500px at 80% 20%, #7a00ff 0%, transparent 60%),
                radial-gradient(700px 700px at 30% 80%, #00e1ff 0%, transparent 60%),
                radial-gradient(600px 600px at 80% 80%, #ff3ba7 0%, transparent 60%);
    filter: blur(60px);
    animation: move 18s infinite alternate ease-in-out;
  }
  @keyframes move{
    0%{transform:translate3d(0,0,0) scale(1);}
    100%{transform:translate3d(-5%,3%,0) scale(1.05);}
  }

  /* 中央配置 */
  .wrap{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:14px;
  }
  /* ガラスパネル（ボード外側） */
  .glass{
    display:flex;flex-direction:column;align-items:center;gap:8px;
    padding:12px;border-radius:18px;
    background: var(--glass-bg);
    border:1px solid var(--glass-border);
    box-shadow: var(--shadow);
    -webkit-backdrop-filter: blur(12px) saturate(140%);
    backdrop-filter: blur(12px) saturate(140%);
  }
  .topbar{
    display:flex;gap:10px;align-items:center;justify-content:space-between;width:100%;
  }
  .badge{
    padding:6px 10px;border-radius:999px;
    background: rgba(255,255,255,0.12);
    border:1px solid var(--glass-border);
    font-weight:600;font-size:14px;letter-spacing:.2px;
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
  }
  canvas{
    display:block;
    width:min(80vw, 420px);
    height:calc(min(80vw, 420px) * 2);
    /* キャンバスは透明→下のブラーが透ける */
    background: rgba(255,255,255,0.04);
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.2);
  }

  /* コントローラ（モバイル向け） */
  .controls{
    display:grid;grid-template-columns:repeat(4,1fr);gap:10px;width:min(90vw, 460px);
  }
  .btn{
    padding:14px 10px;border-radius:14px;
    background: var(--glass-bg);
    border:1px solid var(--glass-border);
    box-shadow: var(--shadow);
    font-size:16px;font-weight:700;text-align:center;user-select:none;
    -webkit-user-select:none;
    -webkit-backdrop-filter: blur(10px) saturate(160%);
    backdrop-filter: blur(10px) saturate(160%);
    touch-action:none;
  }
  .btn:active{transform:scale(0.98);}

  .footer{
    font-size:12px;opacity:.85;text-shadow:0 1px 1px rgba(0,0,0,.25);
  }

  /* 小さな端末でも上下が見切れないよう少し縮小 */
  @media (max-height:700px){
    canvas{ height:calc(min(72vw, 360px) * 2); width:min(72vw, 360px); }
  }
</style>
</head>
<body>
<div class="bg" aria-hidden="true"></div>
<div class="wrap">
  <div class="glass" id="panel">
    <div class="topbar" style="width:100%;">
      <div class="badge">SCORE: <span id="score">0</span></div>
      <div class="badge">LEVEL: <span id="level">1</span></div>
      <div class="badge">LINES: <span id="lines">0</span></div>
    </div>
    <canvas id="game" width="200" height="400" aria-label="Tetris Board"></canvas>
  </div>

  <div class="controls">
    <div class="btn" data-act="left">◀︎ 左</div>
    <div class="btn" data-act="rotate">⟳ 回転</div>
    <div class="btn" data-act="drop">⬇︎ ソフト</div>
    <div class="btn" data-act="right">右 ▶︎</div>
    <div class="btn" data-act="hard">⬇︎⬇︎ ハード</div>
    <div class="btn" data-act="pause">⏸ 一時停止</div>
    <div class="btn" data-act="new">⟲ リスタート</div>
    <div class="btn" data-act="mute">🔈 音 ON/OFF</div>
  </div>

  <div class="footer">Glass Tetris – iOS Safari対応（スワイプ：左右移動 / タップ：回転 / 下スワイプ：ドロップ）</div>
</div>

<script>
(() => {
  // 基本設定
  const COLS = 10, ROWS = 20, SIZE = 20; // 200x400
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const panel = document.getElementById('panel');

  // 7種テトロミノ定義
  const SHAPES = {
    I: [[1,1,1,1]],
    J: [[1,0,0],[1,1,1]],
    L: [[0,0,1],[1,1,1]],
    O: [[1,1],[1,1]],
    S: [[0,1,1],[1,1,0]],
    Z: [[1,1,0],[0,1,1]],
    T: [[0,1,0],[1,1,1]],
  };
  const COLORS = {
    I: '#7AD7FF',
    J: '#90A8FF',
    L: '#FFB870',
    O: '#FFE36E',
    S: '#7DFFA5',
    Z: '#FF7A8A',
    T: '#C07DFF'
  };

  // 効果音（超短いbeep、iOSでも再生しやすいようAudioContext）
  const audioCtx = (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined')
      ? new (window.AudioContext || window.webkitAudioContext)() : null;
  let muted = false;
  function beep(freq=440, dur=0.05, type='sine'){
    if(!audioCtx || muted) return;
    try{
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      o.connect(g); g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      o.start(); o.stop(audioCtx.currentTime + dur);
    }catch(e){/* no-op */}
  }

  // 盤面
  function newMatrix(w,h){
    const m = [];
    for(let y=0;y<h;y++){ m[y] = new Array(w).fill(null); }
    return m;
  }
  const board = newMatrix(COLS, ROWS);

  function randomPiece(){
    const keys = Object.keys(SHAPES);
    const k = keys[(keys.length * Math.random())|0];
    const shape = SHAPES[k].map(r=>r.slice());
    return {k, shape, x: (COLS/2|0)-1, y: 0};
  }
  let current = randomPiece();
  let nextDrop = 0;
  let dropInterval = 900; // ms（レベルで早く）
  let score=0, level=1, lines=0;
  let paused = false;
  let gameOver = false;

  function rotate(mat){
    const N = mat.length, M = mat[0].length;
    const res = Array.from({length:M}, _=>Array(N).fill(0));
    for(let y=0;y<N;y++) for(let x=0;x<M;x++){ res[x][N-1-y] = mat[y][x]; }
    return res;
  }

  function collide(b, p){
    const {shape, x, y} = p;
    for(let sy=0; sy<shape.length; sy++){
      for(let sx=0; sx<shape[0].length; sx++){
        if(shape[sy][sx]){
          const nx = x + sx;
          const ny = y + sy;
          if(nx<0 || nx>=COLS || ny>=ROWS) return true;
          if(ny>=0 && b[ny][nx]) return true;
        }
      }
    }
    return false;
  }

  function merge(b, p){
    const {shape, x, y, k} = p;
    for(let sy=0; sy<shape.length; sy++){
      for(let sx=0; sx<shape[0].length; sx++){
        if(shape[sy][sx]){
          const ny = y + sy, nx = x + sx;
          if(ny>=0) b[ny][nx] = k;
        }
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    outer: for(let y=ROWS-1; y>=0; y--){
      for(let x=0; x<COLS; x++){
        if(!board[y][x]) continue outer;
      }
      // 行が埋まった
      const row = board.splice(y,1)[0];
      board.unshift(new Array(COLS).fill(null));
      cleared++; y++;
    }
    if(cleared>0){
      const add = [0,100,300,500,800][cleared];
      score += add * level;
      lines += cleared;
      if(lines >= level*8){ // 8ライン毎にレベルUP
        level++; dropInterval = Math.max(120, 900 - (level-1)*90);
        beep(900,0.08,'square');
      }else{
        beep(700,0.06,'square');
      }
      updateHUD();
    }
  }

  function updateHUD(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function drawCell(x,y,color,alpha=0.85){
    const px = x*SIZE, py=y*SIZE;
    // 半透明カラー
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(px+1, py+1, SIZE-2, SIZE-2);
    // 光沢ハイライト
    const grad = ctx.createLinearGradient(px,py,px,py+SIZE);
    grad.addColorStop(0, 'rgba(255,255,255,0.45)');
    grad.addColorStop(0.3,'rgba(255,255,255,0.12)');
    grad.addColorStop(1,'rgba(0,0,0,0.15)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = grad;
    ctx.fillRect(px+1, py+1, SIZE-2, (SIZE-2));
    // 薄い内側枠
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px+1.5, py+1.5, SIZE-3, SIZE-3);
  }

  function draw(){
    // キャンバスクリア（透明）
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 盤の背景をガラスっぽく（軽いグラデ）
    const bg = ctx.createLinearGradient(0,0,0,canvas.height);
    bg.addColorStop(0,'rgba(255,255,255,0.06)');
    bg.addColorStop(1,'rgba(255,255,255,0.02)');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 固定ブロック
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const k = board[y][x];
        if(k) drawCell(x,y,COLORS[k],0.9);
      }
    }
    // ゴースト（落下位置ガイド）
    const ghost = {...current, y: current.y};
    while(!collide(board, {...ghost, y:ghost.y+1})) ghost.y++;
    ctx.globalAlpha = 0.25;
    for(let sy=0; sy<ghost.shape.length; sy++){
      for(let sx=0; sx<ghost.shape[0].length; sx++){
        if(ghost.shape[sy][sx]){
          drawCell(ghost.x+sx, ghost.y+sy, COLORS[ghost.k], 0.25);
        }
      }
    }
    ctx.globalAlpha = 1;

    // 落下ブロック
    for(let sy=0; sy<current.shape.length; sy++){
      for(let sx=0; sx<current.shape[0].length; sx++){
        if(current.shape[sy][sx]){
          drawCell(current.x+sx, current.y+sy, COLORS[current.k], 0.85);
        }
      }
    }

    if(gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, canvas.height/2-30, canvas.width, 60);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER - リスタートで再開', canvas.width/2, canvas.height/2+6);
    }
  }

  function step(timestamp){
    if(paused || gameOver){ draw(); requestAnimationFrame(step); return; }
    if(!nextDrop) nextDrop = timestamp + dropInterval;
    if(timestamp >= nextDrop){
      nextDrop = timestamp + dropInterval;
      if(!move(0,1)){
        // 固定
        merge(board, current);
        clearLines();
        current = randomPiece();
        if(collide(board, current)){
          gameOver = true;
          beep(180,0.2,'sawtooth');
        }else{
          beep(420,0.04,'triangle');
        }
      }
    }
    draw();
    requestAnimationFrame(step);
  }

  function move(dx,dy){
    const p = {...current, x: current.x+dx, y: current.y+dy};
    if(!collide(board,p)){ current = p; return true; }
    return false;
  }
  function rotateCurrent(){
    const rot = rotate(current.shape);
    const p = {...current, shape: rot};
    // 壁蹴り簡易版
    if(!collide(board,p)){ current = p; return true; }
    if(!collide(board,{...p,x:p.x-1})){ current.x--; current.shape = rot; return true; }
    if(!collide(board,{...p,x:p.x+1})){ current.x++; current.shape = rot; return true; }
    return false;
  }
  function hardDrop(){
    let moved = false;
    while(move(0,1)) moved = true;
    beep(600,0.06,'square');
    // 固定
    merge(board, current);
    clearLines();
    current = randomPiece();
    if(collide(board, current)){
      gameOver = true;
      beep(180,0.2,'sawtooth');
    }
  }

  // 入力（キーボード & タッチ）
  const KEYS = {
    ArrowLeft: () => move(-1,0),
    ArrowRight:()=> move(1,0),
    ArrowDown: ()=> move(0,1),
    ArrowUp:   ()=> rotateCurrent(),
    Space:     ()=> hardDrop(),
    KeyP:      ()=> togglePause(),
  };
  window.addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    const fn = KEYS[e.code];
    if(fn){ e.preventDefault(); fn(); draw(); }
  }, {passive:false});

  // ボタン
  document.querySelectorAll('.btn').forEach(b=>{
    const act = b.getAttribute('data-act');
    function handle(){
      if(act==='left') move(-1,0);
      else if(act==='right') move(1,0);
      else if(act==='drop') move(0,1);
      else if(act==='rotate') rotateCurrent();
      else if(act==='hard') hardDrop();
      else if(act==='pause') togglePause();
      else if(act==='new') restart();
      else if(act==='mute'){ muted = !muted; b.textContent = muted ? '🔇 音 OFF' : '🔈 音 ON/OFF'; }
      draw();
    }
    b.addEventListener('touchstart', (e)=>{ e.preventDefault(); handle(); }, {passive:false});
    b.addEventListener('click', handle);
  });

  // スワイプ操作（キャンバス）：左右=移動、タップ=回転、下スワイプ=ハードドロップ、上スワイプ=一時停止
  let startX=0, startY=0, moved=false, startTime=0;
  canvas.style.touchAction = 'none';
  canvas.addEventListener('touchstart',(e)=>{
    if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
    const t = e.changedTouches[0];
    startX=t.clientX; startY=t.clientY; moved=false; startTime=Date.now();
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchmove',(e)=>{
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    const ax = Math.abs(dx), ay=Math.abs(dy);
    if(!moved && (ax>18 || ay>18)){
      if(ax>ay){ // 横移動
        if(dx>0) move(1,0); else move(-1,0);
        beep(380,0.03,'triangle');
      }else{ // 縦
        if(dy>0){ hardDrop(); } else { togglePause(); }
      }
      moved=true; draw();
    }
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener('touchend',(e)=>{
    if(!moved){
      // タップ→回転（長押しは無視）
      if(Date.now()-startTime<250){ rotateCurrent(); beep(520,0.03,'sine'); draw(); }
    }
    e.preventDefault();
  }, {passive:false});

  function togglePause(){
    paused = !paused;
    if(!paused && audioCtx && audioCtx.state==='suspended'){ audioCtx.resume().catch(()=>{}); }
  }

  function restart(){
    for(let y=0;y<ROWS;y++) board[y].fill(null);
    current = randomPiece();
    score=0; level=1; lines=0; dropInterval=900; gameOver=false; paused=false;
    updateHUD(); beep(600,0.06,'square');
  }

  // 初期化
  updateHUD();
  requestAnimationFrame(step);

  // iOSでのビューポート固定（アドレスバー伸縮によるズレ軽減）
  // 体感調整：画面回転時にキャンバスを即時再描画
  window.addEventListener('orientationchange', ()=> setTimeout(draw, 300));
  window.addEventListener('resize', ()=> setTimeout(draw, 100));

  // アクセシビリティ：パネルタップでポーズ切替
  panel.addEventListener('dblclick', ()=>togglePause());
})();
</script>
</body>
</html>
